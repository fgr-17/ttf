\chapter{Diseño e Implementación} % Main chapter title

\label{Chapter3} % Change X to a consecutive number; for referencing this chapter elsewhere, use \ref{ChapterX}
\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}

\lstset{ %
  backgroundcolor=\color{white},   % choose the background color; you must add \usepackage{color} or \usepackage{xcolor}
  basicstyle=\footnotesize,        % the size of the fonts that are used for the code
  breakatwhitespace=false,         % sets if automatic breaks should only happen at whitespace
  breaklines=true,                 % sets automatic line breaking
  captionpos=b,                    % sets the caption-position to bottom
  commentstyle=\color{mygreen},    % comment style
  deletekeywords={...},            % if you want to delete keywords from the given language
  %escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
  %extendedchars=true,              % lets you use non-ASCII characters; for 8-bits encodings only, does not work with UTF-8
  %frame=single,	                   % adds a frame around the code
  keepspaces=true,                 % keeps spaces in text, useful for keeping indentation of code (possibly needs columns=flexible)
  keywordstyle=\color{blue},       % keyword style
  language=[ANSI]C,					% the language of the code
  %otherkeywords={*,...},           % if you want to add more keywords to the set
  numbers=left,                    % where to put the line-numbers; possible values are (none, left, right)
  numbersep=5pt,                   % how far the line-numbers are from the code
  numberstyle=\tiny\color{mygray}, % the style that is used for the line-numbers
  rulecolor=\color{black},         % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))
  showspaces=false,                % show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
  showstringspaces=false,          % underline spaces within strings only
  showtabs=false,                  % show tabs within strings adding particular underscores
  stepnumber=1,                    % the step between two line-numbers. If it's 1, each line will be numbered
  stringstyle=\color{mymauve},     % string literal style
  tabsize=2,	                   % sets default tabsize to 2 spaces
  title=\lstname,                   % show the filename of files included with \lstinputlisting; also try caption instead of title
  morecomment=[s]{/*}{*/}%
}

\externaldocument{Chapter2}

% -------------------------------------

Este capítulo se centra en el proceso de desarrollo del dispositivo, tanto el firmware como hardware. Se exponen todas las fases de avance a partir del  modelo en V, que  es el modelo de construcción elegido.
% --------------------------------------


\section{Implementación del firmware}

\subsection{Resumen del sistema}

El equipo digitaliza señales analógicas provenientes de dos sensores de presión intrarterial del tipo strain-gauge y almacena las señales por períodos de alrededor de 24 hs. Estas señales adquiridas se guardan en una memoria de tipo flash (memoria micro SD), y pueden descargarse a una PC a través de una interfaz USB. Desde la PC se accede a los archivos guardados como un medio de almacenamiento masivo, y se pueden visualizar en cualquier software que permita procesar un archivo de tipo ".csv".

Previo a cada experiencia, el operador configura el dispositivo desde una terminal Bluetooth (una tablet o una PC, por ejemplo) a través de un protocolo de comunicación que se desarrolló para este dispositivo. A través de esta interfaz se configuran parámetros como la frecuencia de muestreo, la cantidad de canales a usar, ganancia del amplificador programable, seteo de hora y fecha, y finalmente se da inicio a la medición. 

El equipo consiste en un sistema embebido portátil basado en un microcontrolador ARM de 32 bits, Cortex M3: LPC1769, un conversor analógico digital de alta resolución (ADS1292), módulos de comunicación (serie, BLE, USB), almacenamiento masivo (microSD) y módulo de regulación de energía y carga de batería. Puede verse un diagrama en bloques en la Figura \ref{fig:diag_bloques}. 


\begin{figure}[!htbp]
	\centering
	\includegraphics[width=\textwidth]{./Figures/diag_bloques.png}
	\caption{Diagrama en bloques del equipo.}
	\label{fig:diag_bloques}
\end{figure}

\subsection{Modelo de desarrollo del firmware}


El proceso elegido para el desarrollo del firmware es el modelo en V. Se trata de un modelo descripto en términos de un proceso de construcción descendente ("Software Development Life Cycle", SDLC) y un proceso de verificación y validación ascendente ("Software Test Life Cycle", STLC) \citep{fowler2015}. El punto que une estos dos procesos es la implementación del código. 
Durante el proceso descendente se descomponen y clarifican las necesidades del cliente, dando lugar a los requisitos específicos, diseño de la arquitectura en términos generales y diseño detallado de cada uno de los bloques de código. Luego, cada uno de estos niveles de la fase de construcción se asocia con un nivel de la fase de pruebas, donde se realizan las pruebas unitarias, pruebas de integración y pruebas de sistema. Gráficamente puede visualizarse como una V, de acuerdo a la Figura \ref{fig:modeloV}.

\begin{figure}[!htbp]
	\centering
	\includegraphics[width=\textwidth]{./Figures/modeloV.png}
	\caption{Modelo de desarrollo y validación en V}
	\label{fig:modeloV}
\end{figure}

En las subsecciones \ref{analisisReq}, \ref{disAltoNivel} y \ref{disDetallado} se pone en relieve cada una de estas instancias del proceso de desarrollo.

\subsection{Analisis de los requerimientos} \label{analisisReq}

A partir de un análisis de los requerimientos explicitados en la sección \ref{requerimientos} se puede determinar que los Requerimientos 1 y 2 están estrictamente asociados al hardware. Alguno de estos requerimientos se ligan al firmware, como por ejemplo el R1.1, ya que el firmware es el responsable de la entrada a modos de bajo consumo o la administración de energía dentro del microcontrolador. Sin embargo, la mayor carga de responsabilidad de cumplimiento de estos requerimientos están volcados sobre el hardware. Los requerimientos 3 y 4 son muy cercanos al desarrollo del firmware del equipo. Solamente el requerimiento 4.2 está relacionado al tamaño de la memoria utilizada, que es puramente una cuestión de hardware.

Una vez iniciado el proceso de desarrollo se notó que la lista de requerimientos del capítulo \ref{Chapter2} no es exhaustiva y da por supuesto las funcionalidades básicas del equipo. Se procedió entonces a elaborar una serie de requerimientos más específicos sobre el funcionamiento detallado de la operación del usuario y los parámetros que es posible configurar, tal que permita luego asociar requisitos puntuales a los casos de uso del equipo. 

A continuación se plantean requerimientos adicionales a los presentados en la sección \ref{requerimientos}:

\textbf{Requerimientos adicionales :}

\begin{enumerate}

	\setcounter{enumi}{4}

	\item \textbf{Requerimientos estructurales:} 
	\begin{enumerate}[label*=\arabic*.]
		\item El equipo debe poder adquirir señales analógicas de hasta dos canales de entrada.
		\item El desfasaje entre las señales adquiridas debe ser menor a diez veces la frecuencia de muestreo.
	\end{enumerate}
	
	\item \textbf{Requerimientos operativos:}
	\begin{enumerate}[label*=\arabic*.]
		\item Al estar inactivo, el equipo debe entrar en modo configuración para poder ponerse en hora y mantenerla mientras tenga batería.
		\item Al estar en configuración, se debe poder chequear el correcto funcionamiento del hardware (SD, conversor AD, etc).
		\item Si el equipo esta inactivo, al enviar un comando desde la terminal, se comienza a adquirir y enviar vía Bluetooth (esta señal puede estar decimada y con menor resolución) con la configuración previamente seleccionada.
		\item Si el equipo está adquiriendo y enviando vía Bluetooth, se puede enviar una orden para que el equipo finalice y vuelva al modo inactivo.
		\item Si el equipo está adquiriendo y enviando vía Bluetooth, se puede enviar una orden para que el equipo comience a almacenar en la memoria SD.
		\item Si se esta adquiriendo, enviando señal vía Bluetooth y almacenando en la SD, se debe poder enviar una orden para que el equipo deje de hacerlo y vuelva al modo inactivo.
		\item Si se esta adquiriendo, almacenando y enviando por Bluetooth, se debe poder enviar una orden para que el equipo deje de enviar la señal por Bluetooth y continúe la experiencia en forma silenciosa.
		\item Si el equipo está adquiriendo y almacenando en forma silenciosa, se debe poder enviar un comando para que vuelva a enviar la señal por Bluetooth sin interrumpir ni alterar la adquisición y almacenamiento.
		\item Si el equipo está adquiriendo, enviando señal via Bluetooth y almacenando, se puede enviar un comando para que el equipo deje almacenar.
		\item Si el equipo esta inactivo, se puede requerir el envío de una señal patrón para chequeo del canal de comunicación.
		\item Si el equipo esta enviando la señal patrón para chequeo de canal de comunicación, se puede enviar un comando para que el equipo vuelva a modo inactivo.
		\item Se debe almacenar por cada registro la hora, los canales activados y el nivel de batería.
		\item Cada vez que se comienza un nuevo almacenamiento, se genera un archivo nuevo con nombre auto numerado.
		\item Cada vez que comienza o finaliza un almacenamiento, se registra en un archivo que debe contener el nombre del archivo y la fecha y hora de inicio y fin de todas las experiencias.
		\item Cada uno de estos modos debe estar señalizado por uno o mas leds para comprobar visualmente el funcionamiento.
	\end{enumerate}
	
	\item \textbf{Requerimientos de configuración}
	
	\begin{enumerate} [label*=\arabic*.]
		\item El equipo debe tener una configuración por default y la posibilidad de modificarla mientras no se esta adquiriendo.
		\item El equipo debe poder volver a la configuración de fábrica.
		\item El equipo debe guardar la última configuración y utilizarla.
		\item Se debe poder elegir la frecuencia de muestreo dentro de algunas opciones.
		\item Se debe poder elegir si activar uno o los dos canales.
		\item Se debe poder elegir la ganancia del amplificador.
		\item El equipo se debe poder calibrar con dos puntos de presión conocidos.		
	\end{enumerate}


\end{enumerate}

\textbf{Casos de Uso:}

De toda la lista completa de requerimientos surgen los casos de uso con operaciones básicas del usuario. A continuación se muestran los diferentes casos de uso que se desprenden de los requerimientos:

	\underline{Caso de uso CU0001:}

	\begin{enumerate} 
		\item Nombre: CU0001
		\begin{enumerate} [label*=\arabic*.]
			\item Descripción: Autonomía
			\item Actor Principal: Usuario
			\item Disparador: Encendido del equipo		
		\end{enumerate}
		\item Flujo de eventos
		\begin{enumerate} [label*=\arabic*.]
			\item Flujo básico: el usuario enciende el equipo, realiza la configuración y comienza la experiencia. Luego de 24 hs finaliza la experiencia desde una terminal.
			\item Flujo alternativo: Si la batería no tiene carga total, es responsabilidad del usuario. Según la configuración se puede calcular autonomía aproximada.
		\end{enumerate}

		\item Requerimientos especiales: conexión Bluetooth
		\item Pre-condiciones: cargar la batería al 100\% antes de comenzar a usar el equipo.
		\item Post-Condiciones: Finalizar correctamente la experiencia.				
	\end{enumerate}

	\underline{Caso de uso CU0002:}

	\begin{enumerate} 
		\item Nombre: CU0002
		\begin{enumerate} [label*=\arabic*.]
			\item Descripción: Configuración
			\item Actor Principal: Usuario
			\item Disparador: Ingreso a configuración desde la terminal
		\end{enumerate}
		\item Flujo de eventos
		\begin{enumerate} [label*=\arabic*.]
			\item Flujo básico: el usuario desde la terminal ingresa al modo configuración, modifica los parámetros que necesita o calibra un canal, y vuelve a salir del modo configuración.
			\item Flujo alternativo:
			\begin{itemize}
				\item Si el equipo no está sincronizado, indica error y da la oportunidad de reiniciar. 
				\item Si no se puede abrir la última configuración, debe abrir la configuración de fábrica y mostrar error.
				\item La nueva configuración elegida se guarda y se comprueba al comenzar la experiencia. Hasta ese momento no se comprueba si es correcta.
				\item Si se comprueba algún error de hardware, se debe enviar un mensaje de reparación.						
			\end{itemize}				
		\end{enumerate}

		\item Requerimientos especiales: conexión Bluetooth
		\item Pre-condiciones: equipo en modo inactivo
		\item Post-Condiciones: salir correctamente del modo configuración.
	\end{enumerate}



	\underline{Caso de uso CU0003:}

	\begin{enumerate} 
		\item Nombre: CU0003
		\begin{enumerate} [label*=\arabic*.]
			\item Descripción: Experiencia
			\item Actor Principal: Usuario
			\item Disparador: Ingreso a experiencia desde la terminal
		\end{enumerate}
		\item Flujo de eventos
		\begin{enumerate} [label*=\arabic*.]
			\item Flujo básico: el usuario desde la terminal ingresa al modo de adquisición y visualización, comprueba el correcto funcionamiento de los sensores habilitados observando la señal adquirida. Luego ingresa al modo almacenamiento y comprueba que no haya error en el almacenamiento de datos. Luego selecciona dejar de enviar para que la experiencia continúe en modo silencioso. Al finalizar la experiencia, el usuario envía la orden para terminar la adquisición. El usuario luego comprueba que la adquisición fue completa.
			\item Flujo alternativo:
			\begin{itemize}
				\item Si los sensores no muestran una señal adecuada, se debe salir de la adquisición y chequear conectores.
				\item Si los sensores no muestran ninguna señal, se debe comprobar el canal.
				\item Si hay error al comenzar a almacenar, se detiene la adquisición para comprobar el funcionamiento de la tarjeta SD.
				\item Si se necesita ver las señales por una eventual desconexión, se puede conectar mediante Bluetooth para visualizar las señales y luego salir. 
				\item Si no se puede volver a conectar con la terminal, se debe acceder físicamente a conectar el equipo a una PC.
				\item Si la batería esta en un nivel crítico, el equipo debe guardar el archivo y finalizar la experiencia. El usuario se notifica de esto al intentar conectarse.					
			\end{itemize}				
		\end{enumerate}

		\item Requerimientos especiales: conexión Bluetooth
		\item Pre-condiciones: equipo en modo inactivo
		\item Post-Condiciones: salir correctamente de la experiencia.
	\end{enumerate}

	\underline{Caso de uso CU0004:}

	\begin{enumerate} 
		\item Nombre: CU0004
		\begin{enumerate} [label*=\arabic*.]
			\item Descripción: Descarga de datos y carga de batería.
			\item Actor Principal: Usuario
			\item Disparador: Conectar el equipo por USB a PC
		\end{enumerate}
		\item Flujo de eventos
		\begin{enumerate} [label*=\arabic*.]
			\item Flujo básico: el usuario conecta el equipo a la PC y comprueba que se reconozca como un medio de almacenamiento masivo. Luego descarga los archivos que sean necesarios y deja el equipo conectado mientras necesite cargar la batería. Finalmente, luego de finalizadas todas las transferencias de datos, desconecta el equipo del USB.
			\item Flujo alternativo:
			\begin{itemize}
				\item Si la PC no reconoce al equipo como medio de almacenamiento masivo, se debe comprobar la tarjeta SD.
				\item Si el equipo no carga la batería, se debe hacer una revisión técnica del equipo y de las baterías.			
			\end{itemize}				
		\end{enumerate}

		\item Requerimientos especiales: conexión USB
		\item Pre-condiciones: equipo en modo inactivo
		\item Post-Condiciones: desconectar el USB cuando no haya ninguna transferencia activa y cuando haya terminado de cargar la batería. El nivel de batería se puede comprobar desde la terminal entrando al modo configuración.
	\end{enumerate}
	
A partir de los requerimientos y casos de uso se arma la matriz de trazabilidad, que consiste en una tabla de doble entrada que asocia cada requerimiento con uno o más casos de uso. La matriz de trazabilidad se presenta en la Tabla \ref{tab:matrizTrazabilidad}

\footnotesize

\begin{longtable}[c]{llllll}
\caption{Matriz de Trazabilidad} \\
\hline
\textbf{REQ/CU} & \textbf{CU0001} & \textbf{CU0002} & \textbf{CU0003} & \textbf{CU0004} &             \textbf{Ensayo} \\ \hline
\endhead
%
R1.1 & X &  &  &  & \begin{tabular}[c]{@{}l@{}}Comprobación post-experiencia\\ 			Medición de corriente consumida\end{tabular} \\ \hline
R1.2 &  &  &  &  & Conexión desde terminal \\ \hline
R2.1 &  &  &  &  & Pesaje del equipo \\ \hline
R2.2 &  &  &  &  & Medición del equipo \\ \hline
R2.3 &  &  &  &  & Medición temperatura \textless 40º \\ \hline
R3.1 &  &  & X &  & Test MDE \\ \hline
R3.2 &  &  & X &  & Test MDE \\ \hline
R3.3 &  & X &  &  & Comprobación post-experiencia \\ \hline
R4.1 &  &  & X &  & Test Calibración \\ \hline
R4.2 &  &  & X & X & \begin{tabular}[c]{@{}l@{}}Test conexión PC\\ 			Comprobación post-experiencia\end{tabular} \\ \hline
R4.3 &  &  &  & X & Comprobación post-experiencia \\ \hline
R5.1 &  &  & X &  & Comprobación post-experiencia \\ \hline
R5.2 &  &  & X &  & Comprobación post-experiencia \\ \hline
R6.1 &  &  & X &  & Test MDE \\ \hline
R6.2 &  &  & X &  & Test MDE \\ \hline
R6.3 &  &  & X &  & Test MDE \\ \hline
R6.4 &  &  & X &  & Test MDE \\ \hline
R6.5 &  &  & X &  & Test MDE \\ \hline
R6.6 &  &  & X &  & Test MDE \\ \hline
R6.7 &  &  & X &  & Test MDE \\ \hline
R6.8 &  &  & X &  & Test MDE \\ \hline
R6.9 &  &  & X &  & Test MDE \\ \hline
R6.10 &  &  & X &  & Test MDE \\ \hline
R6.11 &  &  & X &  & Test MDE \\ \hline
R6.12 &  &  & X & X & Comprobación post-experiencia \\ \hline
R6.13 &  &  & X & X & Comprobación post-experiencia \\ \hline
R6.14 &  &  &  & X & Comprobación post-experiencia \\ \hline
R6.15 &  &  & X &  & Comprobación visual \\ \hline
R7.1 &  & X &  &  & Comprobación post-experiencia \\ \hline
R7.2 &  & X &  &  & Comprobación post-experiencia \\ \hline
R7.3 &  & X &  &  & Comprobación post-experiencia \\ \hline
R7.4 &  & X &  &  & Comprobación post-experiencia \\ \hline
R7.5 &  & X &  &  & Comprobación post-experiencia \\ \hline
R7.6 &  & X &  &  & Comprobación post-experiencia \\ \hline
\label{tab:matrizTrazabilidad}\\
\end{longtable}

\normalsize


\subsection{Diseño de alto nivel} \label{disAltoNivel}

Una vez especificados y analizados todos los requerimientos, se da a lugar al diseño del sistema en alto nivel, es decir, analizar los subsitemas que lo conforman y su relación entre sí. Los subsistemas que entran en juego se presentan en la Tabla \ref{tab:subsistemas}, son los bloques básicos desde de los cuales se conforma el dispositivo. Es necesario recurrir a patrones de diseño \citep{douglass2011} para articular entre sí los diferentes módulos.

\footnotesize
\begin{tabularx}{\textwidth}{XXXX}
\caption{Subsistemas del equipo} \\
\hline
\textbf{Subsistema} & \textbf{Responsabilidad} & \textbf{Entrada} & \textbf{Salida} \\ \hline
Sensores & Sensar señal de presión & Señal física de presión & Señal analógica \\ \hline
Acondicionamiento analógico & Filtrar y ajustar ganancia de señal analógica & Señal analógica de presión & Señal analógica de presión acondicionada \\ \hline
ADS1292 & Adquirir señal analógica & Señal analógica de presión acondicionada & Señal digital via SPIPin Data Ready \\ \hline
SD & Almacenar señal adquirida & Paquete de muestras de señales adquiridas & Archivos csv con muestras y archivo con registro de actividad \\ \hline
Led & Indicadores de estado & Niveles lógicos & Encendido o apagado como indicador \\ \hline
Sistema de alimentación y carga de batería & - Cargar la batería al conectar por USB- Alimentar el sistema al no tener conectado el USB a partir de la batería & Tensión USB o de batería & -Corriente de alimentación de USB - Tensión regulada \\ \hline
USB & - proveer tensión para carga de batería- conectividad a PC via medio de almacenamiento masivo & Conector USB a PC & Visualización de sistemas de archivos interna \\ \hline
Bluetooth & Conectividad con terminal & Comandos vía BT & Comandos y datos vía BT \\ \hline
\label{tab:subsistemas}\\
\end{tabularx}
\normalsize



\textbf{Patrones de Diseño:}

En primer lugar, la cadena de adquisición, envío de datos y almacenamiento se asocia a un patrón productor/consumidor, donde el conversor analógico digital ADS1292 y ADC interno son los productores de datos, y las salidas por Bluetooth y almacenamiento en la SD son los consumidores. La información producida se guarda en un ping-pong buffer \citep{zhou2017} del cual leen las demás tareas. Esto puede visualizarse en la figura \ref{fig:patronProdCons}.

En este patrón también participa el esquema de "\textit{proxy pattern}", que se refiere a un esquema de funcionamiento en el que un elemento de software es el responsable del acceso a un recurso de hardware, y todas las tareas que quieran acceder al recurso lo hacen a través de este elemento. Se utiliza una estructura o clase que encapsule todos los accesos al hardware, sin importar su interfaz física. Este proxy publica los servicios que permiten leer y escribir en el dispositivo, así como inicializar, configurar y apagar el dispositivo. En el diagrama de la figura \ref{fig:patronProdCons} pueden verse en verde todos los elementos de hardware, y con flechas la interfaz física través del cual se comunica. 

\begin{figure}[!htbp]
	\centering
	\includegraphics[width=\textwidth]{./Figures/VOP24_patron_dis2.png}
	\caption{Diagrama de relaciones entre subsistemas. Patrón productor/consumidor}
	\label{fig:patronProdCons}
\end{figure}

Los módulos de hardware que se muestran en la figura \ref{fig:patronProdCons} son los siguientes:

\begin{itemize}
	\item ADS1292: se trata de un conversor analógico digital de alta resolución (24 bits), con dos canales de entrada diferencial simultáneos, de tecnología Sigma-Delta. Incluye internamente un amplificador de ganancia programable (PGA). Puede trabajar a una frecuencia de muestreo máxima de 8kSPS. La interfaz de comunicación es a través de un bus SPI \citep{texas2012} . El conversor tiene dos modos de operación: puede indicar con el pin DRDY que cuenta con datos a ser leídos y esperar el comando RDATA, o puede estar en el modo “Read Data Continous” (RDATAC) y enviar comandos constantemente. En el diagrama anterior se muestra la conexión a través del pin DRDY para mostrar el caso general y ser compatible con cualquiera de los dos modos de envío de datos.
	\item Bluetooth: la conexión Bluetooth se realiza a través de un módulo HC-06. Se conecta al microcontrolador a través de un puerto serie y permite la comunicación entre el software de la terminal y la aplicación guardada en el firmware. Cuenta con un pin de habilitación y una salida de STATE para indicar cuando hay vigente una conexión Bluetooth.
	\item Serie: solamente se utiliza para desarrollo y pruebas de comunicación. Físicamente se trata de un conversor USB-TTL y se maneja a través de un driver de la UART.
	\item SD: el medio de almacenamiento masivo del dispositivo es una tarjeta microSD. La placa cuenta con un slot de microSD que permite la conexión entre la tarjeta y el microcontrolador a través de un bus SPI, además de un pin que permite detectar cuando hay una tarjeta conectada. La interfaz entre la aplicación y el hardware se hace en dos capas: la aplicación se comunica con el nivel de manejo de archivos (librería FatFs), y esta librería se comunica con las funciones del driver SPI \citep{chan2014}, como se visualiza en la figura \ref{fig:capasFatFs}.
	
\begin{figure}[!htbp]
	\centering
	\includegraphics[scale =0.2]{./Figures/capasFatFs.png}
	\caption{Capas de software de la librería FatFs}
	\label{fig:capasFatFs}
\end{figure}	
	
	\item ADC: se trata de un conversor analógico digital interno al microcontrolador, de 12 bits de resolución, 8 canales multiplexados, de tecnología SAR (aproximaciones sucesivas). Se habilita la conversión a través de la habilitación de un timer que temporiza la frecuencia de muestreo. Los resultados de la conversión del ADC se transfieren a memoria a través del DMA.
	\item DMA: uno de los canales está configurado en modo “PERIPHERAL TO MEMORY”, realizando las transferencias entre el periférico ADC y un puntero que apunta a un buffer. En cada transferencia el puntero se incrementa hasta llegar al final y generar una interrupción. 
\end{itemize}

\subsection{Diseño Detallado} \label{disDetallado}

En base al diseño de alto nivel realizado, se da a lugar al diseño detallado de los elementos del programa como tareas y máquinas de estado.

\clearpage
\textbf{Diseño de tareas}

El firmware está basado en el sistema operativo de tiempo real freeRTOS \citep{aws2017}.  En el diagrama de la figura \ref{fig:tareasCompleto} se puede observar un esquema detallado de las tareas involucradas y las relaciones entre ellas. 

\begin{adjustbox}{center,caption={Diagrama de tareas completo},label={fig:tareasCompleto},nofloat=figure,vspace=\bigskipamount}
\includegraphics[scale = 0.35, angle=90]{./Figures/VOP24_tareas_v1.png}
\label{tareasCompleto}
\end{adjustbox}

Cada una de las filas del gráfico \ref{tareasCompleto} corresponde a un nivel de prioridad, siendo “cero” el nivel de menor prioridad y “cuatro” el de máxima prioridad utilizado. El nivel “IRQ” corresponde a las rutinas de atención de interrupción, que en el sistema freeRTOS tienen una prioridad siempre mayor a cualquiera de las tareas. En verde se pueden ver los mecanismos de comunicación entre tareas, como semáforos o colas de datos. Las flechas que no tienen ninguna indicación corresponden a flags, estados o asignación directa de variables de menor complejidad. 
	
El diagrama de la figura \ref{fig:tareasCompleto} ilustra en detalle el funcionamiento del firmware. En el nivel de prioridad 1 se encuentran las tareas de interfaz con el usuario, que son de menor prioridad porque no tienen una exigencia crítica de tiempo. Se explica a continuación el funcionamiento en diferentes casos:

\begin{itemize}

	\item Al iniciar el equipo, solo está activa la tarea “InterfazTerminal()”, que es la encargada de comunicarse con el usuario remoto respetando el diagrama de estados de la figura \ref{fig:tareasInactivo}. En este caso solamente intervienen esta tarea, la tarea UART\_CanalSalida(), que es una tarea cercana al hardware que hace la interfaz entre la cola de datos de salida y el registro de la UART, y finalmente la propia rutina de interrupción de la UART que escribe en la cola de datos de entrada cada vez que recibe un mensaje, y envía los datos de salida permitiendo escribirse en bloques hasta del tamaño de la FIFO interna del periférico (16 bytes). En nivel de prioridad cero siempre se ejecuta una tarea que señaliza con parpadeo de leds según el modo de funcionamiento activo. En este caso, es un parpadeo cada 500ms.

\begin{adjustbox}{center,caption={Diagrama de tareas en modo inactivo},label={fig:tareasInactivo},nofloat=figure,vspace=\bigskipamount}
\includegraphics[scale = 0.33]{./Figures/VOP24_tareas_v1_modoInactivoConf.png}
\end{adjustbox}

	\item Cuando el equipo pasa al modo “adquirir+enviar”, se inicializa el hardware de adquisición (ADS1292), que se comunica a través del bus SPI0 y de una entrada de propósito general (GPIO) conectada al pin DRDY. Como se explicó anteriormente, uno de los modos de funcionamiento del ADS1292 es señalizar a través del pin DRDY la disponibilidad de datos nuevos para ser leídos. La rutina de interrupción de GPIO “EINT3\_handler()” se activa en cada nivel bajo del pin DRDY, y libera el semáforo “semBinADS1292DRDY”. Por otro lado, esto libera la tarea “DatosListos()” que se encontraba en estado bloqueado en espera de este semáforo, para luego enviar el comando RDATA a través del bus SPI, y recibir finalmente el dato leído para almacenarlo en un buffer. 

		Al ingresar al modo “adquirir+enviar” se instala una tarea llamada “EnviarSgn()”, que se encuentra bloqueada a través de la cola de datos “colaDatosEnv”. La tarea “DatosListos()” envía un puntero a buffer a través de esta cola de datos cada vez que se completa un buffer de adquisición, de manera que la tarea “EnviarSgn()” también escriba en la cola de datos de salida de la UART, “colaUART”.
		
\begin{adjustbox}{center,caption={Diagrama de tareas en modo adquirir y enviar},label={fig:VOP24_tareas_v1_adquirirEnviar},nofloat=figure,vspace=\bigskipamount}
\includegraphics[scale = 0.32]{./Figures/VOP24_tareas_v1_adquirirEnviar.png}
\end{adjustbox}		
		
	\item Al ingresar al modo “adquirir+enviar+almacenar”, se agrega la tarea “Almacenar()”, que también se encuentra bloqueada a través de una cola de datos llamada “colaDatosAlm”, a través de la cual se envía un puntero a buffer a ser guardado en la memoria SD. 
	
\begin{adjustbox}{center,caption={Diagrama de tareas en modo adquirir, enviar y almacenar},label={fig:VOP24_tareas_v1_adquirirEnviarAlmacenar},nofloat=figure,vspace=\bigskipamount}
\includegraphics[angle= 90, scale = 0.33]{./Figures/VOP24_tareas_v1_adquirirEnviarAlmacenar.png}
\end{adjustbox}
	
	La tarea Almacenar() se comunica a través de un bus SPI directamente con la tarjeta SD. El tamaño del buffer de almacenamiento se definió haciendo pruebas entre el tiempo de llenado del buffer (cantidad de muestras multiplicado por período de muestreo) versus el tiempo de almacenamiento que demora escribir el buffer como archivo en la memoria SD. Este último tiempo no es lineal a la cantidad de muestras, por lo que se hicieron varias pruebas hasta determinar un tamaño óptimo para el peor caso que es la máxima frecuencia de muestreo posible. El tamaño determinado es de 1024 muestras y se comprobó a 500 muestras por segundo con dos canales habilitados. Al almacenar en la SD también se guardan las muestras de medición de batería. Para ello se hace un promedio de una ráfaga de muestras que se guardan en un buffer “bufBateria” a través del DMA.

	\item Durante el modo “adquirir+almacenar” se suspende la tarea “EnviarSgn()” y el resto de las tareas continúa igual. 

\begin{adjustbox}{center,caption={Diagrama de tareas en modo adquirir y almacenar},label={fig:VOP24_tareas_v1_adquirirAlmacenar},nofloat=figure,vspace=\bigskipamount}
\includegraphics[angle= 90, scale = 0.23]{./Figures/VOP24_tareas_v1_adquirirAlmacenar.png}
\end{adjustbox}

El led pasa a realizar dos parpadeos en un segundo y luego permanece apagado el siguiente segundo. Esta es la indicación visual de que el equipo se encuentra correctamente funcionando mientras el usuario no tenga acceso mediante Bluetooth.

	\item Cuando se conecta el USB a una PC, se activa el handler de la interrupción USB\_Handler y se instala una tarea “InterfazPC()” que espera a que el equipo esté en modo inactivo para luego permitir ver el contenido de la tarjeta de memoria desde la PC como un medio de almacenamiento extraíble. Todas las demás tareas se bloquean mientras el equipo se comunique con la PC: no se puede conectar mediante Bluetooth ni usar ninguna de las funcionalidades anteriores hasta que se desconecte el USB.
	
Mientras se mantiene el USB conectado a una PC, el led permanece oscilando para indicar carga y se habilita la carga de la batería. Una vez finalizada la carga, el led queda prendido permanentemente hasta desconectar el USB.

\begin{adjustbox}{center,caption={Diagrama de tareas en modo conexión USB},label={fig:VOP24_tareas_v1_USB},nofloat=figure,vspace=\bigskipamount}
\includegraphics[angle= 0, scale = 0.23]{./Figures/VOP24_tareas_v1_USB.png}
\end{adjustbox}

	\item Durante el modo “configuracion” interviene solamente la comunicación a través de la UART para el caso de modificar hora y fecha. Al momento de calibrar, es necesario activar la medición con el ADS1292, pero en este caso, el buffer adquirido se promedia para obtener solo una muestra como salida. La comunicación con la tarea “DatosListos()” que toma las muestras en el buffer se hace a través de la cola de datos “colaDatosEnv”.

La medición de batería solamente se calibra al momento de grabar el código en la flash, no se ofrece calibración por menú.

\begin{adjustbox}{center,caption={Diagrama de tareas en modo configuración},label={fig:VOP24_tareas_v1_configuracion},nofloat=figure,vspace=\bigskipamount}
\includegraphics[scale = 0.2]{./Figures/VOP24_tareas_v1_configuracion.png}
\end{adjustbox}

\end{itemize}

\textbf{Diseño de máquinas de estado}

La tarea InterfazTerminal es la encargada de establecer comunicación con el usuario. Se modela como máquina de estados. En la figura \ref{fig:VOP_mde_v1} solamente el flujo posible del programa, no se muestran en el gráfico los comandos específicos que se envían.


\begin{figure}[!htbp]
	\centering
	\includegraphics[scale=0.18]{./Figures/VOP_mde_v1.png}
	\caption{Máquina de estados de tarea de interfaz de usuario}
	\label{fig:VOP_mde_v1}
\end{figure}


El estado de configuración se trata de un estado compuesto en el cual se puede modificar todos los parámetros de adquisición como frecuencia de muestreo, canales habilitados y ganancia PGA. También se  puede cambiar la configuración de fecha y hora y realizar la calibración de un canal. Se modela igualmente como máquina de estados, de acuerdo al diagrama de la figura \ref{fig:VOP24_configuracion_v1}.

\begin{figure}[!htbp]
	\centering
	\includegraphics[scale=0.14]{./Figures/VOP24_configuracion_v1.png}
	\caption{Máquina de estados de configuración de usuario}
	\label{fig:VOP24_configuracion_v1}
\end{figure}

\subsection{Implementación del código} \label{implementacion}

La implementación de código se realizó en etapas, comenzando por los drivers y capas de abstracción de hardware. La biblioteca de código utilizada para la configuración de los periféricos es LPCOpen, que es libre y cuenta con drivers, middleware y gran cantidad de ejemplos \citep{lpcopen2014}.

\textbf{Código de bajo nivel: periféricos}

En primer lugar, de acuerdo al diagrama de gantt de la figura \ref{fig:gantt}, se trabajó sobre cada uno de los drivers de bajo nivel para lograr la funcionalidad individual de los periféricos e integrados asociados. A continuación se mencionan cada una de las particularidades de los diferentes módulos de hardware configurados: 

\begin{itemize}

	\item \textbf{Puerto Serie:} se utilizaron las funciones de LPCOpen Chip\_UART para generar funciones una capa por encima de ellas. Se utilizó un esquema de productor-consumidor como se puede visualizar en la figura \ref{fig:patronProdCons}. El acceso a la UART se simplificó en dos colas de datos, tal cual puede verse en la figura \ref{fig:tareasInactivo}, además de la participación de la tarea UART\_CanalSalida() que es la encargada de dar curso a los bytes escritos en la cola de salida. Se realizaron funciones de inicialización de las estructuras lógicas y de instalación de la tarea involucrada. La estructura de datos utilizada es la siguiente:


\footnotesize 	
\begin{lstlisting} [caption = Estructura de datos asociada al manejo de la UART]

/** @brief  tipo de dato para el manejo general de uart. */

typedef struct {
  uint32_t baudrate;	      /* velocidad del puerto*/
  LPC_USART_T *pUART;		  /* puntero a la estructura de LPCOpen */
  QueueHandle_t colaUARTRx;	  /* cola de datos para recepcion */
  QueueHandle_t colaUARTTx;	  /* cola de datos para transmision */
  SemaphoreHandle_t semThre; /* mutex para controlar la salida de datos */
}uart_t;

\end{lstlisting}	
\normalsize


Las colas de datos manejan punteros a char, que apuntan a buffers de bytes del largo del frame que utiliza el protocolo, en este caso, 4 bytes.
Se agrega además un manejo simple de las FIFO de transmisión y recepción de 16 bytes con las que cuenta el microcontrolador. Por un lado, al escribir sobre el registro de salida, se tiene en cuenta que se pueden escribir hasta 16 bytes y luego hay que esperar a que se libere la FIFO de transmisión. Para ello se creó un semáforo binario llamado semThre que se suelta cada vez que el handler de interrupción detecta una entrada por vaciamiento del registro de transmisión (THRE: transmit holding register empty). 

	\item \textbf{Puerto SPI:} el manejo del bus SPI dedicado a la comunicación con el ADS1292 se realizó utilizando directamente las funciones de bajo nivel de LPCOpen Chip\_SPI\_, ya que la comunicación con el mismo no es muy compleja ni demanda una atención más sofisticada. Una vez inicializado el puerto SPI, se intercambian una serie de comandos con el ADS1292 y no es necesario comunicarse nuevamente con él hasta comenzar la adquisición. Durante la misma, se genera una interrupción a través del pin DRDY y en ese momento se realiza una breve comunicación con el ADS1292 para recibir la muestra adquirida. 
	
	Por otro lado, el puerto SPI dedicado a la comunicación con la memoria SD también se comunica a través de las funciones básicas de la librería LPCOpen, pero se agrega una rutina de atención de interrupción para manejar comandos que requieren envío y respuesta inmediata.

	\item \textbf{Timer:} se utiliza un timer que realiza una cuenta repetitiva para generar la frecuencia de muestreo. No se utilizó el handler de interrupción, simplemente se inicializa y se activa o desactiva cuando es necesario muestrear con el ADC interno.

	\item \textbf{ADC:} el ADC está configurado para ser disparado por el Timer 0 al setear los bits correspondientes del registro de control. Esta conexión entre el ADC y el Timer es interna por hardware, al configurarlo de esta manera, con cada interrupción del Timer se genera un disparo del ADC. Se muestrea un solo canal para la adquisición de la batería.
	
	\item \textbf{DMA:} el DMA esta configurado para generar una transferencia desde un lugar fijo de memoria de periféricos (el registro AD0CR) a un puntero que se incrementa con cada copia. Al finalizar el conteo del buffer se genera una interrupción del DMA y se pasa a calcular un promedio de los valores, a la vez que se intercambia el puntero a un segundo buffer.
	
 	\item \textbf{GPIO:} las entradas utilizadas como propósito general son el pin DRDY para señalizar que el conversor ADS1292 tiene datos listos, un pin de estado del conversor Serie-BT, un pin de detección de tarjeta conectada del slot microSD y la salida de detección de fuente de alimentación. En la rutina de interrupción se liberan semáforos o se escriben flags. También se utilizan salidas digitales manejadas directamente con las funciones de LPCOpen para la activación del integrado de carga de batería. Este último esta normalmente apagado porque aumenta el nivel de ruido de todo el circuito.

	\item \textbf{USB:} se trabajó a partir del ejemplo de LPCOpen usbd\_lib\_hid\_generic, que muestra como utilizar la librería USB para enumerar al dispositivo como Device. También se recurrió a los recursos de software de ejemplo de la placa Embedded Artist\citep{ea2013}, que contiene una implementación de la clase Mass Storage (MSC), con todas las funciones de acceso a memoria y los wrappers para los comandos SCSI que utiliza la MSC \citep{arm2019} \citep{peacock2002} \citep{axelson2006}. La aplicación configura el endpoint 1 para transferencias BULK y permite que el USB tome el control del accesso a la memoria SD, hasta que la PC finalice la comunicación o se detecte mediante el pin USB\_CONNECT que se perdió el vínculo.

\end{itemize}

\textbf{Configuración de drivers}

\begin{itemize}

 	\item \textbf{ADS1292:} el ADS1292 requiere una serie de comandos para su inicialización\cite{texas2012} con delays intermedios. Se envía el comando RESET, luego se espera 1 segundo para después enviar el comando SDATAC. Si el envío es correcto, el ADS1292 responde con una cadena que contiene un ID asociado al modelo del chip (los demás chips de la familia responden ID diferente). 
 	Luego se pasa a escribir los registros de configuración CONFIG1 y CONFIG2, donde se especifican las referencias de tensión, la frecuencia de muestreo, los canales habilitados y la ganancia del PGA de cada canal. Al finalizar, se baja el pin de Chip Select del bus SPI. 
 	Después de inicializarlo, el manejo del ADS1292 se realiza en la tarea DatosListos(), que está bloqueada por el semáforo del pin DRDY. Cada vez que este semáforo desbloquea la tarea, activo el canal SPI con el pin Chip Select y leo los bytes recibidos. Luego se empaquetan los tres bytes en una variable de 32 bits utilizando una unión y se almacenan en un buffer. Cuando los buffers de los canales habilitados están completos, se intercambian los punteros de almacenamiento y adquisición, y finalmente se escribe en la cola de datos colaDatosAlm o colaDatosEnv según el modo actual.
 	Se utiliza una estructura de datos para cada uno de los canales con los siguientes campos:
 	
\footnotesize 	
\begin{lstlisting} [caption = Estructura de datos asociada al canal del ADS1292]

typedef enum {INACTIVO, PENDIENTE, PROCESANDO, FINALIZADO} T_Estado_Buffer;

typedef struct
{
	/* Defino un doble buffer para adquisicion.  */
	int32_t buf1 [CANAL_BUFFER_L];
	int32_t buf2 [CANAL_BUFFER_L];

	/* Indice de adquisicion */
	int32_t ind;
	/* Indice de envio */
	int32_t ind_envio;

	/* Defino puntero a buffer de adquisicionn y a buffer de almacenamiento: */
	int32_t* pAct;
	int32_t* pAlm;


	/* flag para saber si hay un buffer lleno esperando a almacenarse */
	T_Estado_Buffer estado_buffer;
	bool buffer_lleno_pendiente;
}t_canal;


\end{lstlisting}	
\normalsize

 	
 	\item \textbf{Bluetooth:} la comunicación por Bluetooth es transparente y se utiliza directamente como un puerto serie. La configuración del módulo HC-05 se realiza mediante una PC y el módulo se emplea ya inicializado.

	\item \textbf{Memoria SD:} el manejo de la memoria SD se realiza a través de las librerías FatFs. Se cuenta con funciones de inicialización de la capa más baja de hardware(disk\_initialize) y de inicialización del filesystem (f\_mount). Una vez que la memoria ya se encuentra montada, se pueden utilizar funciones de acceso a archivos como f\_open(), f\_write(), f\_sync(), f\_close(). Todas estas funciones recurren al driver SPI.

\end{itemize}

\subsection{Pruebas Unitarias} \label{pruebasUnitarias}


Para cada uno de los periféricos y drivers mencionados anteriormente se realizaron scripts individuales para comprobar el funcionamiento en forma aislada.

\textbf{Pruebas sobre periféricos:}

\begin{itemize}

\item \textbf{Puerto Serie:} se hizo la prueba de comunicación utilizando inicialmente la placa LPCXpresso1769 y un conversor USB-TTL conectado directamente a los pines del microcontrolador. Se utilizó el programa microcom \citep{ubuntu2016} para realizar las pruebas de comunicación serie entre la PC y el microcontrolador.

\item \textbf{Puerto SPI:} las pruebas de comunicación SPI se realizaron en primer lugar con un osciloscopio digital Tektronix TDS2012C para verificar la frecuencia de la señal SCK. Luego se realizaron las pruebas directamente sobre los dispositivos a los que se conectan, como la memoria SD y el ADS1292, y ello permitió corregir errores de configuración del puerto.

\item \textbf{Timer:} se comprobó el funcionamiento del timer instalando un handler de interrupción básico que haga cambiar el estado de un pin. Luego se modificó la frecuencia de la interrupción y se comprobó para cada caso la frecuencia de parpadeo del pin en un osciloscopio digital Tektronix TDS2012C.

\item \textbf{ADC:} se realizaron pruebas de adquisición utilizando un generador de señales UTG4082A con señales senoidales para el análisis de frecuencia y señales tipo rampa para la comprobación del rango dinámico. Se utilizaron diferentes frecuencias de muestreo y para cada caso se realizó un descargo de memoria RAM del microcontrolador a un archivo, para su posterior visualización y análisis utilizando un script de python.

\item \textbf{DMA:} se comprobó la configuración del DMA utilizando el ADC y realizando adquisiciones, y se comprobó el correcto funcionamiento descargando los buffers de memoria transferidos por este periférico. La descarga de memoria se realizó igual que en el caso de la comprobación de funcionamiento del ADC, utilizando la herramienta de "Memory Dump" de la IDE LPCXpresso, que permite exportar un sector de la memoria del microcontrolador a un archivo en la PC, para luego analizarlo en un script de python.

\item \textbf{GPIO:} se realizaron pruebas de la configuración de los pines de salida utilzando la placa LPCXpresso1769 y leds conectados a través de un protoboard. Se realizaron pruebas para los pines de entrada utilizando la placa LPCXpresso1769 y un botón conectado a través de un protoboar, y comprobando el acceso a la rutina de interrupción.

\item \textbf{USB:} las pruebas de USB se realizaron en conjunto con las pruebas de hardware ya que es necesario para la comunicación con la PC. Para los test iniciales se utilizó un programa que registra al microcontrolador como un puerto serie a través del USB, y con ello se realizaron algunas correcciones de hardware. Luego se realizaron las pruebas individuales de la memoria SD y se comprobó su funcionamiento utilizando un lector de memorias USB. Finalmente se integró todo en un mismo programa para realizar la prueba en conjunto del USB y la memoria SD.

\end{itemize}


\textbf{Pruebas sobre drivers:}


\begin{itemize}

\item \textbf{ADS1292:} se realizaron pruebas de adquisición armando un programa básico que solamente cuente con una rutina de interrupción para el pin de aviso de datos disponibles (DRDY) y una tarea que permita realizar la copia de las muestras de los canales habilitados hacia un buffer. Se colocó un breakpoint que detenga el programa al finalizar la escritura del buffer y se realizó una descarga de la memoria a un archivo para verificar la adquisición, al igual que con la prueba del periférico ADC interno. Se conectó la entrada analógica del ADC a un generador de señales arbitrario UNI-T UTG4082A y se realizaron adquisiciones sobre señales senoidales y del tipo rampa, para verificar la característica de respuesta en frecuencia y de rango dinámico. 

\item \textbf{Bluetooth:} se utilizó un módulo HC-05 conectado al puerto serie, y se emparejó luego a una tablet con Android, con la aplicación Blueterm\citep{pymasde2013} instalada. Se realizaron pruebas de envío de comandos individuales, y luego de señales guardadas en la memoria del microcontrolador en bloques de 128 bytes, decimando las muestras a 100Hz y bajando la resolución de 24 a 16 bits. En la aplicación se realizó una descarga de memoria para comprobar que los bloques de memoria hayan sido transferidos correctamente.

\item \textbf{Memoria SD:} las pruebas de este driver se realizaron en conjunto con las pruebas de hardware. En primer lugar se realizó la prueba de conexión con la memoria SD, escritura de un archivo y luego apertura de un archivo. Finalmente se realizaron pruebas más exigentes en tiempo haciendo escrituras de buffers completos y midiendo el tiempo de escritura en la SD con un pin digital de salida: antes de ingresar a la función de escritura de la SD se estableció el estado del pin en 3.3V, y al salir de la función de escritura del bloque se volvió a establecer el estado del pin en 0V. Esto es necesario ya que se debe demorar menos tiempo en escribir el bloque adquirido en la SD que en adquirir dicho bloque. Luego de estas pruebas se configuró el tamaño del buffer de muestras en 1024 muestras.

\end{itemize}

\subsection{Pruebas de Integración} \label{pruebasIntegracion}

Las pruebas de integración se realizaron a partir de la aplicación principal esquematizada en la figura \ref{fig:VOP_mde_v1}. Esta aplicación abarca todas las funcionalidades del equipo excepto el acceso por USB. Al ser la máquina de estados totalmente conocida, y poder acceder mediante el debugger a la posición real del firmware del controlador (estados observables), se puede realizar una prueba exhaustiva de la función de interfaz de usuario. 
Utilizando la aplicación Blueterm en una tablet con Android se realizó el recorrido por todos los estados posibles de la máquina (All-Path Coverage \citep{lin2013}), así como también se enviaron comandos erróneos o fuera de contexto. Estas pruebas permitieron corregir errores en las prioridades y tamaño de stack asignado a cada tarea.
Luego se realizaron las mismas pruebas, pero en lugar de verificar el funcionamiento mediante el debugger, se realizó mediante un puerto serie auxiliar, y agregando mensajes de testing en el firmware, que luego se removieron en la versión final. Esto permitió independizar la prueba de las demoras del debugger.


\subsection{Pruebas de Sistema} \label{pruebasSistema}

Las pruebas de sistema se discutirán en el capítulo 4 como ''Ensayos y Resultados'' a partir de los casos de uso.

\section{Implementación del Hardware} \label{implementacionHw}

El desarrollo del hardware se realizó en tres etapas: dos etapas como prototipo experimental y una tercera con todas las correcciones como modelo final. Cabe destacar que los dos primeros circuitos son impresos preliminares y se realizaron sin restricciones de tamaño, de orden o estéticas, sólo se se le dió prioridad a la funcionalidad y correccion de errores. En la sub sección \ref{disFinal} se presenta la versión definitiva. Todos los modelos fueron diseñados íntegramente en Kicad.

\subsection{Prototipo para adquisición del ADS1292}

En primer lugar se realizó una placa como prototipo para prueba del ADS1292 y su conexión con el microcontrolador. En este caso se colocaron dos tiras de pines para conectar la placa LPCXpresso1769, y el ADS1292 a través del puerto SPI0, asi como también un filtro analógico de entrada, basado en un circuito recomendado por el fabricante de los sensores. Se utilizó un regulador de tensión LDO 7333 para independizar la alimentación utilizando baterías o un adaptador de 4V a 9V, y de esta manera reducir el ruido que introduce la alimentación por USB de la placa LPCXpresso1769. 
Se realizó el ruteo independiente de la alimentación digital (DVCC-DGND) y analógica (AVCC-AGND). En la figura \ref{fig:ads1292esq} puede verse un esquemático con las conexiones de entrada del ADS1292.

\begin{figure}[!htbp]
	\centering
	
	\begin{minipage}{\textwidth}
		\includegraphics[width=\textwidth]{./Figures/ads1292_esq.png}		
	\end{minipage}		
	
	\caption{Esquemático de conexiones del conversor analógico digital de alta resolución ADS1292}
	\label{fig:ads1292esq}
\end{figure}



Este PCB se realizó en un router CNC redt MAGIC300 (Figura \ref{fig:magic300}) sobre una placa de cobre virgen doble faz de 10x5 cm. Se realizaron varias correcciones sobre la misma. Se agregó también un slot de memoria micro SD conectado al puerto SPI0 para realizar las primeras pruebas de adquisición. Pueden verse fotografías de este prototipo luego de haber realizado varias correcciones en las Figura \ref{fig:prototipo1sup}.

\begin{figure}[!htbp]
	\centering
	
	\includegraphics[width=0.65\textwidth]{./Figures/magic300.jpeg}		
	
	\caption{Router CNC empleado para los dos primeros prototipos.}
	\label{fig:magic300}
\end{figure}

\begin{figure}[!htbp]
	\centering
	\includegraphics[width=0.65\textwidth]{./Figures/prototipo1conLPCXpresso.jpeg}		
	\caption{Vista superior e inferior del primer prototipo realizado con LPCXpresso montado.}
	\label{fig:prototipo1sup}
\end{figure}


\subsection{Prototipo para carga de batería y USB}

En segundo lugar se trabajó en un prototipo para realizar la carga de la batería y el accesso a datos a través del puerto USB. 

Para la carga de la batería se utilizó el integrado LT1512, que permite realizar la carga a corriente constante y tensión controlada por una resistencia. También reduce al mínimo la corriente de perdida de la batería y cuenta con un pin de habilitación. Este integrado toma la tensión de línea de USB, que es la que se utiliza para realizar la carga. El bus USB se encuentra protegido por el integrado TPD4S014, tanto la línea de tensión como las líneas de datos.


\begin{figure}[!htbp]
	\centering
	
	\includegraphics[width=0.8\textwidth]{./Figures/usbesq.png}		

	
	\caption{Esquemático de conexión de la entrada USB}
	\label{fig:usbesq}
\end{figure}

\begin{figure}[!htbp]
	\centering
	

	\includegraphics[width=0.8\textwidth]{./Figures/cargaesq.png}		

	
	\caption{Esquemático de conexión de la entrada USB}
	\label{fig:cargaesq}
\end{figure}


Para el intercambio de tensión entre la batería y la tensión provista por el bus USB se utilizó el circuito integrado LTC4411 que cumple la función de un ''diodo ideal'', es decir, permite intercambiar entre una tensión y otra en un tiempo mínimo de establecimiento. A su vez cuenta con un pin de salida que le indica al microcontrolador cuál es la tensión que está conectada.


\begin{figure}[!htbp]
	\centering
	
	\includegraphics[width=0.8\textwidth]{./Figures/switchBateria.png}		
	
	\caption{Esquemático de conexión del LTC4411.}
	\label{fig:switchBateria}
\end{figure}

Además se incluyeron dos tipos de reguladores para prueba: por un lado un regulador LDO de 3.3V MCP1700-3302, y por otro un regulador buck-boost TPS63001. Este último requiere algunos componentes más pero permite regular la salida a 3.3V desde 5.5V hasta 1.8V, lo que permite aprovechar mejor la autonomía de la batería. Se realizaron pruebas para medir el nivel de ruido de la salida de este regulador. En todos los casos se incluyeron jumpers que permitieron activar cada regulador por separado.

\begin{figure}[!htbp]
	\centering
	\includegraphics[width=0.8\textwidth]{./Figures/reguladores.png}			
	\caption{Esquemático de conexión los reguladores.}
	\label{fig:reguladores}
\end{figure}

Este prototipo se fabricó también en un router CNC redt Magic300 en una sola capa por su baja complejidad. Se realizaron pruebas de todas las funcionalidades y a partir de ello se tomó nota de todas las correcciones para la versión final. Pueden verse fotografías de la placa finalizada en las figuras \ref{fig:pcbBateriaInf} y \ref{fig:pcbBateriaSup} .

\begin{figure}[!htbp]
	\centering	
	\includegraphics[width=0.6\textwidth]{./Figures/pcbBateriaInf.png}			
	\caption{Modelo en KiCAD del circuito impreso del prototipo para carga de batería y USB}
	\label{fig:pcbBateriaInf}
\end{figure}

\begin{figure}[!htbp]
	\centering	
	\includegraphics[width=0.6\textwidth]{./Figures/pcbBateriaSup.jpeg}			
	\caption{Vista superior del prototipo para carga de bateria y USB}
	\label{fig:pcbBateriaSup}
\end{figure}


\subsection{Diseño final del circuito impreso} \label{disFinal}

Utilizando los dos prototipos anteriores y los esquemáticos de la placa LPCXpresso1769 \citep{ea2011} se realizó un diseño integrando todos estos módulos, y con el microcontrolador LPC1769 soldado sobre la placa en lugar de utilizar la placa de desarrollo LPCXpresso1769. 

En este diseño también se agregaron los siguientes módulos:

\begin{itemize}

\item Amplificador operacional en modo seguidor conectado a una entrada del ADC para medir el nivel de batería y una entrada analógica adicional de baja resolución para una futura expansión. El resto de los esquemáticos son los mismos que los utilizados para los prototipos anteriores con leves correcciones.

\item Puerto serie UART0 conectado a una tira de pines con el orden del módulo Bluetooth HC-05

\item Puerto serie UART3 conectado a una tira de pines para conectar un módulo USB-TTL para log y debug.

\item Se optó por el regulador de tensión TPS63001 ya que la diferencia del nivel de ruido con los reguladores LDO es mínima.

\item El módulo del microcontrolador LPC1769, que es relativamente sencillo: contiene los cristales de alta y baja frecuencia y una serie de capacitores de filtro de tensión. A diferencia del esquemático de la placa LPCXpresso1769, se separaron las conexiones de tensión digital y analógica, de acuerdo a lo indicado en el manual del microcontrolador. Puede verse parte de su esquemático en la figura \ref{fig:esqlpc1769}. También 
se incluyó una tira de pines al puerto SWD para programar el microcontrolador utilizando la placa LPCLink de NXP \citep{nxp2013}.


\begin{figure}[!htbp]
	\centering	
	\includegraphics[width=0.9\textwidth]{./Figures/esqlpc1769.png}			
	\caption{Conexiones del microcontrolador LPC1769}
	\label{fig:esqlpc1769}
\end{figure}

\end{itemize}

De acuerdo a los Requerimientos 2.1 y 2.2 se procedió al diseño de un circuito impreso lo más pequeño posible. Se establecieron las medidas de 4x4cm, pero resultó ser insuficiente y se optó finalmente por un tamaño de 6x6 cm. Se realizó una placa doble faz y se terciarizó su fabricación en la empresa Seeed Studio (https://www.seeedstudio.io/). En las figura \ref{fig:cadFinal} se presentan ambas caras del diseño CAD enviado a fabricar.

\begin{figure}[!htbp]
	\centering	
	\includegraphics[width=0.9\textwidth]{./Figures/pcbFinal.png}			
	\caption{Vista frontal y trasera del diseño CAD del impreso final}
	\label{fig:cadFinal}
\end{figure}

\begin{figure}[!htbp]
	\centering	
	\includegraphics[width=0.9\textwidth]{./Figures/pcbFinalSinComponentes.jpeg}			
	\caption{Vista frontal y trasera del circuito impreso fabricado sin componentes}
	\label{fig:pcbFinalSinComponentes}
\end{figure}

\begin{figure}[!htbp]
	\centering	
	\includegraphics[width=0.9\textwidth]{./Figures/pcbFinalSoldado.png}			
	\caption{Vista frontal y trasera del circuito impreso fabricado con componentes}
	\label{fig:pcbFinalSoldado}
\end{figure}